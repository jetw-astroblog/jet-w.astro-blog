---
import type { SEOProps } from '@jet-w/astro-blog/types';
import { siteConfig, defaultSEO } from '@jet-w/astro-blog/config';
import '@jet-w/astro-blog/styles/global.css';
import fs from 'node:fs';
import path from 'node:path';
import {
  getLocaleFromPath,
  getLocaleConfig,
  getAlternateLinks,
  getTextDirection,
  isMultiLanguageEnabled,
  withBase,
  t,
  type I18nConfig,
} from '../utils/i18n';
import { defaultI18nConfig } from '../config/i18n';
// Import i18n config from virtual module (injected by integration)
import { i18nConfig as virtualI18nConfig } from 'virtual:astro-blog-i18n';

export interface Props {
  title?: string;
  description?: string;
  image?: string;
  type?: 'website' | 'article';
  publishedTime?: string;
  modifiedTime?: string;
  tags?: string[];
  i18nConfig?: I18nConfig;
}

const {
  title = defaultSEO.title,
  description = defaultSEO.description,
  image = defaultSEO.image,
  type = 'website',
  publishedTime,
  modifiedTime,
  tags,
  i18nConfig = virtualI18nConfig || defaultI18nConfig,
} = Astro.props;

// Get current locale from URL
const currentLocale = getLocaleFromPath(Astro.url.pathname, i18nConfig);
const localeConfig = getLocaleConfig(currentLocale, i18nConfig);
const localeData = localeConfig.locale;
const ui = localeConfig.ui;

// Use locale-specific site config if available
const localeSiteConfig = localeConfig.site;

const canonicalURL = new URL(Astro.url.pathname, Astro.site);
const siteTitle = localeSiteConfig.title || siteConfig.title;
const fullTitle = title === siteTitle ? title : `${title} | ${siteTitle}`;
const fullImage = new URL(image, Astro.site);

// Get alternate links for SEO (hreflang)
const baseUrl = Astro.site?.toString() || '';
const alternateLinks = isMultiLanguageEnabled(i18nConfig)
  ? getAlternateLinks(Astro.url.pathname, baseUrl, i18nConfig)
  : [];

// Get locale prefix for RSS link
const rssPath = currentLocale === i18nConfig.defaultLocale && !i18nConfig.routing.prefixDefaultLocale
  ? '/rss.xml'
  : `/${currentLocale}/rss.xml`;

const publicDir = path.join(process.cwd(), 'public');
const faviconSvgExists = fs.existsSync(path.join(publicDir, 'favicon.svg'));
const faviconIcoExists = fs.existsSync(path.join(publicDir, 'favicon.ico'));
const faviconHref = faviconSvgExists ? '/favicon.svg' : faviconIcoExists ? '/favicon.ico' : siteConfig.avatar;
const faviconType = faviconSvgExists ? 'image/svg+xml' : faviconIcoExists ? 'image/x-icon' : 'image/jpeg';

// Get base URL for prefixing links
const base = import.meta.env.BASE_URL;
---

<!DOCTYPE html>
<html lang={localeData.htmlLang} dir={getTextDirection(currentLocale, i18nConfig)} class="scroll-smooth">
  <head>
    <meta charset="UTF-8" />
    <meta name="description" content={description} />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" type={faviconType} href={withBase(faviconHref || '', base)} />
    <meta name="generator" content={Astro.generator} />

    <!-- SEO -->
    <title>{fullTitle}</title>
    <link rel="canonical" href={canonicalURL} />

    <!-- Alternate language links (hreflang) -->
    {alternateLinks.map(link => (
      <link rel="alternate" hreflang={link.hreflang} href={link.url} />
    ))}

    <!-- Open Graph -->
    <meta property="og:type" content={type} />
    <meta property="og:title" content={fullTitle} />
    <meta property="og:description" content={description} />
    <meta property="og:url" content={canonicalURL} />
    <meta property="og:image" content={fullImage} />
    <meta property="og:site_name" content={siteTitle} />
    <meta property="og:locale" content={localeData.htmlLang} />

    {publishedTime && (
      <meta property="article:published_time" content={publishedTime} />
    )}
    {modifiedTime && (
      <meta property="article:modified_time" content={modifiedTime} />
    )}
    {tags && tags.map(tag => (
      <meta property="article:tag" content={tag} />
    ))}

    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content={fullTitle} />
    <meta name="twitter:description" content={description} />
    <meta name="twitter:image" content={fullImage} />

    <!-- RSS -->
    <link rel="alternate" type="application/rss+xml" title={siteTitle} href={withBase(rssPath, base)} />

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />

    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" crossorigin="anonymous" />
    <!-- Material Icons -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons|Material+Icons+Outlined|Material+Icons+Round" />
    <!-- Bootstrap Icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css" />
    <!-- Remix Icon -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/remixicon@4.2.0/fonts/remixicon.css" />
    <!-- KaTeX for LaTeX math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous" />
    <!-- Ionicons -->
    <script type="module" src="https://unpkg.com/ionicons@7.1.0/dist/ionicons/ionicons.esm.js"></script>

    <script is:inline>
      const theme = (() => {
        if (typeof localStorage !== 'undefined' && localStorage.getItem('theme')) {
          return localStorage.getItem('theme');
        }
        if (window.matchMedia('(prefers-color-scheme: light)').matches) {
          return 'light';
        }
        return 'dark';
      })();

      if (theme === 'light') {
        document.documentElement.classList.remove('dark');
      } else {
        document.documentElement.classList.add('dark');
      }
      window.__theme = theme;
    </script>
  </head>
  <body class="min-h-screen w-full overflow-x-hidden">
    <div id="app" class="flex flex-col min-h-screen w-full min-w-0">
      <slot />
    </div>

    <!-- Mermaid -->
    <script src={withBase('/js/mermaid-container.js', base)} is:inline></script>

    <!-- Tabs -->
    <script src={withBase('/js/tabs-init.js', base)} is:inline></script>

    <!-- Store i18n data for client-side scripts -->
    <script is:inline define:vars={{ locale: currentLocale, uiTranslations: ui }}>
      window.__i18n = {
        locale: locale,
        ui: uiTranslations
      };
    </script>

    <script>
      // Get i18n translations
      const i18n = (window as any).__i18n || { locale: 'zh-CN', ui: {} };
      const ui = i18n.ui;

      // Back to top
      const backToTop = document.querySelector('.back-to-top');
      if (backToTop) {
        window.addEventListener('scroll', () => {
          if (window.scrollY > 300) {
            backToTop.classList.add('show');
          } else {
            backToTop.classList.remove('show');
          }
        });

        backToTop.addEventListener('click', () => {
          window.scrollTo({ top: 0, behavior: 'smooth' });
        });
      }

      // Smooth scroll for anchor links
      document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener('click', function (this: HTMLAnchorElement, e: Event) {
          e.preventDefault();
          const href = this.getAttribute('href');
          if (href) {
            const target = document.querySelector(href);
            if (target) {
              target.scrollIntoView({ behavior: 'smooth' });
            }
          }
        });
      });

      // Code block enhancement
      function enhanceCodeBlocks() {
        const codeBlocks = document.querySelectorAll('pre:not([data-enhanced])');
        const COLLAPSE_THRESHOLD = 15;

        codeBlocks.forEach((pre) => {
          pre.setAttribute('data-enhanced', 'true');

          const code = pre.querySelector('code');
          let lang = 'code';

          if (code?.classList.contains('language-mermaid') ||
              pre.classList.contains('mermaid') ||
              pre.closest('.mermaid-container')) {
            return;
          }

          if (code) {
            const classList = code.className.split(' ');
            for (const cls of classList) {
              if (cls.startsWith('language-')) {
                lang = cls.replace('language-', '');
                break;
              }
            }
          }

          const preEl = pre as HTMLPreElement;
          if (preEl.dataset.language) {
            lang = preEl.dataset.language;
          }

          const codeText = code ? code.textContent : pre.textContent;
          const lineCount = (codeText || '').split('\n').length;
          const shouldCollapse = lineCount > COLLAPSE_THRESHOLD;

          const wrapper = document.createElement('div');
          wrapper.className = 'code-block-wrapper' + (shouldCollapse ? ' collapsed' : '');

          const header = document.createElement('div');
          header.className = 'code-block-header';
          header.innerHTML = `
            <span class="code-block-lang">${lang}</span>
            <div class="code-block-actions">
              ${shouldCollapse ? `
                <button class="code-block-btn collapse-btn" title="${ui.expand || 'Expand'}/${ui.collapse || 'Collapse'}">
                  <svg class="collapse-icon transition-transform duration-200" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                  </svg>
                  <span class="collapse-text">${ui.expand || 'Expand'}</span>
                </button>
              ` : ''}
              <button class="code-block-btn copy-btn" title="${ui.copyCode || 'Copy'}">
                <svg class="copy-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
                </svg>
                <span class="copy-text">${ui.copyCode || 'Copy'}</span>
              </button>
            </div>
          `;

          const content = document.createElement('div');
          content.className = 'code-block-content';

          if (!pre.parentNode) return;
          pre.parentNode.insertBefore(wrapper, pre);
          wrapper.appendChild(header);
          wrapper.appendChild(content);
          content.appendChild(pre);

          if (shouldCollapse) {
            const expandOverlay = document.createElement('div');
            expandOverlay.className = 'code-block-expand';
            expandOverlay.innerHTML = `
              <button class="expand-btn">
                <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                </svg>
                <span>${ui.expandCode || 'Expand code'} (${lineCount} ${ui.lines || 'lines'})</span>
              </button>
            `;
            content.appendChild(expandOverlay);

            const collapseOverlay = document.createElement('div');
            collapseOverlay.className = 'code-block-collapse';
            collapseOverlay.innerHTML = `
              <button class="collapse-bottom-btn">
                <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 15l7-7 7 7" />
                </svg>
                <span>${ui.collapseCode || 'Collapse code'}</span>
              </button>
            `;
            content.appendChild(collapseOverlay);

            const expandBtn = expandOverlay.querySelector('.expand-btn');
            if (expandBtn) {
              expandBtn.addEventListener('click', () => {
                wrapper.classList.remove('collapsed');
                const collapseText = header.querySelector('.collapse-text') as HTMLElement | null;
                if (collapseText) collapseText.textContent = ui.collapse || 'Collapse';
              });
            }

            const collapseBottomBtn = collapseOverlay.querySelector('.collapse-bottom-btn');
            if (collapseBottomBtn) {
              collapseBottomBtn.addEventListener('click', () => {
                wrapper.classList.add('collapsed');
                const collapseText = header.querySelector('.collapse-text') as HTMLElement | null;
                if (collapseText) collapseText.textContent = ui.expand || 'Expand';
                wrapper.scrollIntoView({ behavior: 'smooth', block: 'start' });
              });
            }
          }

          const copyBtn = header.querySelector('.copy-btn') as HTMLElement | null;
          if (copyBtn) {
            copyBtn.addEventListener('click', async () => {
              const textToCopy = code ? code.textContent : pre.textContent;
              try {
                await navigator.clipboard.writeText(textToCopy || '');
                copyBtn.classList.add('copied');
                const copyText = copyBtn.querySelector('.copy-text') as HTMLElement | null;
                const copyIcon = copyBtn.querySelector('.copy-icon') as HTMLElement | null;
                if (copyText) copyText.textContent = ui.copied || 'Copied';
                if (copyIcon) copyIcon.innerHTML = `
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" />
                `;

                setTimeout(() => {
                  copyBtn.classList.remove('copied');
                  if (copyText) copyText.textContent = ui.copyCode || 'Copy';
                  if (copyIcon) copyIcon.innerHTML = `
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
                  `;
                }, 2000);
              } catch (err) {
                console.error('Copy failed:', err);
              }
            });
          }

          const collapseBtn = header.querySelector('.collapse-btn') as HTMLElement | null;
          if (collapseBtn) {
            collapseBtn.addEventListener('click', () => {
              const isCollapsed = wrapper.classList.toggle('collapsed');
              const collapseText = collapseBtn.querySelector('.collapse-text') as HTMLElement | null;
              if (collapseText) collapseText.textContent = isCollapsed ? (ui.expand || 'Expand') : (ui.collapse || 'Collapse');
            });
          }
        });
      }

      enhanceCodeBlocks();

      const observer = new MutationObserver((mutations) => {
        let hasNewCodeBlocks = false;
        mutations.forEach((mutation) => {
          if (mutation.addedNodes.length) {
            mutation.addedNodes.forEach((node) => {
              if (node.nodeType === 1) {
                const el = node as Element;
                if (el.tagName === 'PRE' || el.querySelector?.('pre:not([data-enhanced])')) {
                  hasNewCodeBlocks = true;
                }
              }
            });
          }
        });
        if (hasNewCodeBlocks) {
          enhanceCodeBlocks();
        }
      });

      observer.observe(document.body, { childList: true, subtree: true });
    </script>

  </body>
</html>
